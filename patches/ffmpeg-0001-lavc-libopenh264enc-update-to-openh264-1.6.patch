From 2898ed2bd5cf369c228b8a564861f0dbba888552 Mon Sep 17 00:00:00 2001
From: Stefano Sabatini <stefasab@gmail.com>
Date: Mon, 7 Mar 2016 18:05:30 +0100
Subject: [PATCH] lavc/libopenh264enc: update to openh264 1.6

In particular, the slice mode API was changed in commit:

commit 33c378f7b791310e4cb64b53e2bb8f3f3bded105
Author: sijchen <sijchen@cisco.com>
Date:   Tue Nov 10 09:50:06 2015 -0800

    change API for slicing part for easier usage (the UseLoadBalancing flag is still under working)

This fixes compilation with latest version of openh264.
---
 configure                   |  2 +-
 doc/encoders.texi           | 25 ++++++++++++++---------
 libavcodec/libopenh264enc.c | 48 ++++++++++++++++++++++-----------------------
 3 files changed, 41 insertions(+), 34 deletions(-)

diff --git a/configure b/configure
index cc2c9e7..587da68 100755
--- a/configure
+++ b/configure
@@ -5625,7 +5625,7 @@ enabled libopencv         && { check_header opencv2/core/core_c.h &&
                                { use_pkg_config opencv opencv2/core/core_c.h cvCreateImageHeader ||
                                  require opencv opencv2/core/core_c.h cvCreateImageHeader -lopencv_core -lopencv_imgproc; } ||
                                require_pkg_config opencv opencv/cxcore.h cvCreateImageHeader; }
-enabled libopenh264       && require_pkg_config openh264 wels/codec_api.h WelsGetCodecVersion
+enabled libopenh264       && require_pkg_config "openh264 >= 1.6" wels/codec_api.h WelsGetCodecVersion
 enabled libopenjpeg       && { check_lib openjpeg-2.1/openjpeg.h opj_version -lopenjp2 -DOPJ_STATIC ||
                                check_lib openjpeg-2.0/openjpeg.h opj_version -lopenjp2 -DOPJ_STATIC ||
                                check_lib openjpeg-1.5/openjpeg.h opj_version -lopenjpeg -DOPJ_STATIC ||
diff --git a/doc/encoders.texi b/doc/encoders.texi
index f38cad3..dfab007 100644
--- a/doc/encoders.texi
+++ b/doc/encoders.texi
@@ -1394,16 +1394,18 @@ Set slice mode. Can assume one of the follwing possible values:
 
 @table @samp
 @item fixed
-a fixed number of slices
-@item rowmb
-one slice per row of macroblocks
-@item auto
-automatic number of slices according to number of threads
-@item dyn
-dynamic slicing
+use a fixed numer of slices, depending on the value of
+@option{slices}. If set to 0, the number of slices is automatically
+selected.
+@item raster
+use a fixed number of macro-blocks per slice. The number of MBs is set
+through @option{slice_mbs}.
+@item sizelimited
+set slicing according to size. The slice size is set through
+@option{max_nal_size}.
 @end table
 
-Default value is @samp{auto}.
+Default value is @samp{fixed}.
 
 @item loopfilter
 Enable loop filter, if set to 1 (automatically enabled). To disable
@@ -1414,7 +1416,12 @@ Set profile restrictions. If set to the value of @samp{main} enable
 CABAC (set the @code{SEncParamExt.iEntropyCodingModeFlag} flag to 1).
 
 @item max_nal_size
-Set maximum NAL size in bytes.
+Set maximum nal size in bytes. This is only used when
+@option{slice_mode} is set to @samp{sizelimited}.
+
+@item slice_mbs
+Set number of MBs per slice. This is only used when
+@option{slice_mode} is set to @samp{raster}.
 
 @item allow_skip_frames
 Allow skipping frames to hit the target bitrate if set to 1.
diff --git a/libavcodec/libopenh264enc.c b/libavcodec/libopenh264enc.c
index 24bc228..3cad405 100644
--- a/libavcodec/libopenh264enc.c
+++ b/libavcodec/libopenh264enc.c
@@ -39,6 +39,7 @@ typedef struct SVCContext {
     int loopfilter;
     char *profile;
     int max_nal_size;
+    int slice_mbs;
     int skip_frames;
     int skipped;
     int cabac;
@@ -51,14 +52,14 @@ typedef struct SVCContext {
 #define OFFSET(x) offsetof(SVCContext, x)
 #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
 static const AVOption options[] = {
-    { "slice_mode", "set slice mode", OFFSET(slice_mode), AV_OPT_TYPE_INT, { .i64 = SM_AUTO_SLICE }, SM_SINGLE_SLICE, SM_RESERVED, VE, "slice_mode" },
-        { "fixed", "a fixed number of slices", 0, AV_OPT_TYPE_CONST, { .i64 = SM_FIXEDSLCNUM_SLICE }, 0, 0, VE, "slice_mode" },
-        { "rowmb", "one slice per row of macroblocks", 0, AV_OPT_TYPE_CONST, { .i64 = SM_ROWMB_SLICE }, 0, 0, VE, "slice_mode" },
-        { "auto", "automatic number of slices according to number of threads", 0, AV_OPT_TYPE_CONST, { .i64 = SM_AUTO_SLICE }, 0, 0, VE, "slice_mode" },
-        { "dyn", "Dynamic slicing", 0, AV_OPT_TYPE_CONST, { .i64 = SM_DYN_SLICE }, 0, 0, VE, "slice_mode" },
+    { "slice_mode", "set slice mode", OFFSET(slice_mode), AV_OPT_TYPE_INT, { .i64 = SM_FIXEDSLCNUM_SLICE }, SM_FIXEDSLCNUM_SLICE, SM_RESERVED, VE, "slice_mode" },
+        { "fixed", "set a fixed number of slices, depending on slices option", 0, AV_OPT_TYPE_CONST, { .i64 = SM_FIXEDSLCNUM_SLICE }, 0, 0, VE, "slice_mode" },
+        { "raster", "set a fixed number of MB per slice, depending on slice_mb option", 0, AV_OPT_TYPE_CONST, { .i64 = SM_RASTER_SLICE }, 0, 0, VE, "slice_mode" },
+        { "sizelimited", "set slice according to size", 0, AV_OPT_TYPE_CONST, { .i64 = SM_SIZELIMITED_SLICE }, 0, 0, VE, "slice_mode" },
     { "loopfilter", "enable loop filter", OFFSET(loopfilter), AV_OPT_TYPE_INT, { .i64 = 1 }, 0, 1, VE },
     { "profile", "set profile restrictions", OFFSET(profile), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VE },
-    { "max_nal_size", "set maximum NAL size in bytes", OFFSET(max_nal_size), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VE },
+    { "slice_size", "set maximum NAL size in bytes", OFFSET(max_nal_size), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VE },
+    { "slice_mbs", "set number of MBs per slice", OFFSET(slice_mbs), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VE },
     { "allow_skip_frames", "allow skipping frames to hit the target bitrate", OFFSET(skip_frames), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, VE },
     { "cabac", "Enable cabac", OFFSET(cabac), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VE },
     { NULL }
@@ -184,29 +185,28 @@ FF_ENABLE_DEPRECATION_WARNINGS
     param.sSpatialLayers[0].iSpatialBitrate     = param.iTargetBitrate;
     param.sSpatialLayers[0].iMaxSpatialBitrate  = param.iMaxBitrate;
 
-    if ((avctx->slices > 1) && (s->max_nal_size)){
-        av_log(avctx,AV_LOG_ERROR,"Invalid combination -slices %d and -max_nal_size %d.\n",avctx->slices,s->max_nal_size);
-        goto fail;
-    }
-
-    if (avctx->slices > 1)
-        s->slice_mode = SM_FIXEDSLCNUM_SLICE;
-
-    if (s->max_nal_size)
-        s->slice_mode = SM_DYN_SLICE;
-
-    param.sSpatialLayers[0].sSliceCfg.uiSliceMode               = s->slice_mode;
-    param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceNum = avctx->slices;
+    param.sSpatialLayers[0].sSliceArgument.uiSliceMode = s->slice_mode;
 
-    if (s->slice_mode == SM_DYN_SLICE) {
-        if (s->max_nal_size){
+    if (s->slice_mode == SM_FIXEDSLCNUM_SLICE) {
+        param.sSpatialLayers[0].sSliceArgument.uiSliceNum = avctx->slices;
+    } else if (s->slice_mode == SM_RASTER_SLICE) {
+        if (s->slice_mbs) {
+            param.sSpatialLayers[0].sSliceArgument.uiSliceMbNum[0] = s->slice_mbs;
+        } else {
+            av_log(avctx, AV_LOG_ERROR, "The value slice_mbs must be set to use slice_mode raster\n");
+            goto fail;
+        }
+    } else if (s->slice_mode == SM_SIZELIMITED_SLICE) {
+        if (s->max_nal_size) {
             param.uiMaxNalSize = s->max_nal_size;
-            param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = s->max_nal_size;
+            param.sSpatialLayers[0].sSliceArgument.uiSliceSizeConstraint = s->max_nal_size;
         } else {
-            av_log(avctx, AV_LOG_ERROR, "Invalid -max_nal_size, "
-                   "specify a valid max_nal_size to use -slice_mode dyn\n");
+            av_log(avctx, AV_LOG_ERROR, "The value max_nal_size must be set to use slice_mode sizelimited\n");
             goto fail;
         }
+    } else {
+        av_log(avctx, AV_LOG_ERROR, "Unknown or invalid selected slice mode %d\n", s->slice_mode);
+        goto fail;
     }
 
     if ((*s->encoder)->InitializeExt(s->encoder, &param) != cmResultSuccess) {
-- 
2.8.2

